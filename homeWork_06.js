/*
Основные идеи принципа KISS:

  Простота должна быть главной целью при проектировании системы. Чем проще система, тем меньше в ней ошибок и тем легче её поддерживать.

  Не стоит добавлять излишнюю функциональность, которая не нужна для решения задачи. Лишняя сложность увеличивает риск ошибок.

  Система должна быть максимально модульной и с минимальными зависимостями между компонентами. Это облегчает тестирование и модификацию.

  Предпочтительнее иметь несколько простых систем, чем одну сложную. Разбиение на простые части уменьшает сложность.

  Абстракции полезны, но их не должно быть слишком много. Абстракции увеличивают сложность.

  Проще - значит лучше. Упрощение системы должно быть основной целью разработчика.

Таким образом, KISS рекомендует делать системы максимально простыми, не усложняя их без необходимости. Это повышает надежность и удобство поддержки.

......................................................................
DRY (Don't Repeat Yourself) - это еще один важный принцип программирования, который означает "не повторяйся".

Основные идеи принципа DRY:

  Каждый кусок функциональности должен иметь единственное непротиворечивое представление в коде.

  Любая логика должна быть записана только в одном месте, а не дублироваться в разных частях кода.

  Дублирование кода плохо, так как увеличивает сложность поддержки и вероятность ошибок.

  Если нужно изменить какую-то логику или правило - должна быть возможность сделать это в одном месте, а не искать все дубликаты.

Причины, почему дублирование вредно:

  При обнаружении ошибки её нужно исправлять во всех копиях кода.

  При изменении логики её нужно менять везде. Легко забыть что-то.

  Дублирование увеличивает объем кода, что усложняет понимание.

  Может возникнуть несогласованность между копиями.

Чтобы следовать DRY, нужно:

  Выносить дублирующиеся фрагменты кода в отдельные функции/методы.

  Создавать общие/базовые классы и наследовать от них для избежания дублирования.

  Использовать конфигурационные файлы для хранения повторяющихся констант.

Таким образом, принцип DRY рекомендует исключать дублирование для упрощения поддержки кода.



.....................................................................
YAGNI (You Aren't Gonna Need It) - это еще один принцип разработки ПО, который рекомендует не реализовывать функциональность, которая не требуется для текущих задач.

Основные идеи YAGNI:

  Не стоит загадывать заранее и добавлять функциональность, которая может понадобиться в будущем.

  Нужно реализовывать только те функции, которые необходимы для текущих user story и задач.

  Добавление неиспользуемого кода усложняет систему и замедляет разработку.

  Требования могут измениться к тому моменту, когда функциональность действительно понадобится. Код придется переписывать.

  Реализация лишней функциональности - пустая трата времени и сил команды.

Причины применения YAGNI:

  Избежать ненужной сложности системы.

  Сосредоточиться на текущих задачах и не тратить ресурсы впустую.

  Избежать преждевременной оптимизации и усложнения архитектуры.

Таким образом, YAGNI рекомендует не заниматься преждевременной реализацией функциональности, а сосредоточиться на текущих задачах.

................................................................................
LocalStorage и sessionStorage - это два способа хранения данных в браузере на стороне клиента. Основные различия:

  Данные в localStorage сохраняются без ограничения срока, пока их явно не удалить. Данные в sessionStorage хранятся до закрытия вкладки браузера.

  Данные в localStorage доступны из любой вкладки и окна браузера. Данные sessionStorage изолированы для каждой вкладки.

  Данные в localStorage не отправляются на сервер при каждом запросе, в отличие от cookie.

  При использовании localStorage данные не теряются при перезагрузке страницы или сбое браузера.

  Данные хранятся в виде пар ключ-значение. Ключи всегда строки.

  Максимальный размер хранилища около 5-10Мб.

  Данные доступны только для скриптов из того же источника, который их сохранил.

Cookie - это небольшой фрагмент данных, который веб-сервер отправляет браузеру для хранения на компьютере пользователя.

Основные свойства cookie:

  Размер каждого cookie ограничен 4KB.

  Cookie хранятся в виде пар "ключ-значение".

  При каждом HTTP запросе на сервер браузер отправляет имеющиеся cookie.

  Сервер может установить время жизни cookie - по истечении оно будет удалено.

  Могут быть установлены ограничения на домены и пути, откуда доступен cookie.

  Cookie доступны как на стороне клиента через JavaScript, так и на стороне сервера.

  Используются для хранения данных о сессии, авторизации, предпочтениях пользователя.

......................................................................................
Основные элементы HTML:

  <!DOCTYPE html> - объявляет тип документа (HTML5).

  <html></html> - корневой элемент HTML документа.

  <head></head> - заголовок документа, содержит метаданные.

  <meta charset="utf-8"> - метатег для указания кодировки.

  <title></title> - заголовок документа.

  <body></body> - содержимое документа, отображаемое в браузере.

  <h1></h1>...<h6></h6> - заголовки разных уровней.

  <p></p> - параграф текста.


БЭМ (Блок, Элемент, Модификатор) - это методология именования классов в HTML и CSS, которая позволяет создавать понятную и легко масштабируемую структуру проекта.

Основные принципы БЭМ:

  Все интерфейс разделяется на независимые блоки.

  Каждый блок может содержать элементы.

  Модификаторы используются для изменения стилей блоков и элементов.

Пример структуры БЭМ:

  .block {}

  .block__element {}

  .block--modifier {}

  .block__element--modifier {}

Преимущества БЭМ:

  Понятная и логичная структура проекта.

  Легкая масштабируемость за счет независимости блоков.

  Повторное использование компонентов.

  Простота внесения изменений благодаря модификаторам.

Таким образом, БЭМ упрощает разработку и поддержку крупных интерфейсов за счет модульности и структурирования кода.

..........................................................................
Вот несколько популярных паттернов, часто используемых в функциональном программировании:

  Иммутабельность - данные не изменяются после создания, что упрощает параллельную обработку и уменьшает ошибки.

  Чистые функции - функции, у которых нет побочных эффектов и результат зависит только от аргументов.

  Рекурсия - использование рекурсивных вызовов функций вместо циклов.

  Каррирование - преобразование функции с множеством аргументов в цепочку функций с одним аргументом.

  Композиция - создание сложных функций путем комбинирования простых.

  Ленивые вычисления - откладывание вычислений до тех пор, пока результат не потребуется.

  Мемоизация - кэширование результатов функций для избежания повторных вычислений.

  Монады - конструкция для цепочного выполнения функций с общим контекстом.

  Функторы и аппликативные функторы - отвечают за применение функций к структурам данных.

Эти паттерны позволяют упростить логику программы и избежать побочных эффектов по сравнению с императивным кодом.

...........................................................................

Существует несколько основных способов позиционирования контента на веб-странице с помощью CSS:

  Базовый(блочный) поток: block
    Элементы распологаются сверху вниз под друг другом, в том порядке в котором они расположены в коде.

  Строчные элементы: inline
    Элементы расположены друг за другом на одной строке слева направо. Нельзя задвать ширину и высоту, горизонтальные и вертикальны выравнивания.

С помощью position мы можем выдернуть любой элемент из потока документа и размпестить его в другом место относительно чего либо.

  Static: элемент позиционируется в документе. Свойства top, right, bottom и left не влияют на конечное местоположение элементов. По умолчанию

  Relative: Свойства top, right, bottom и left влияют. Есть в потоке и влиет на других. Считается относительно позиционированным

  Absolute: Считается отпозиционгированным относительно ближайшего родителя. Свойства top, right, bottom и left влияют. Нет в потоке и не влиет на других

  Fixed: Оно похоже на абсолютное, но в отличии от него всегда привязывается к краям окна браузера (viewport), и остаётся в таком положении даже при скроллинге страницы.

  Sticky: Cмешанное поведение relative и fixed. Фиксируется при прокрутке.

Flexbox
Гибкая одномерная или двумерная разметка с помощью свойств flex-контейнера и flex-элементов.

Grid
Двумерная сеточная разметка с помощью grid-контейнеров, треков и ячеек.

inline-block:

  Отображаются в строку, как строчные элементы (inline).
  Могут задавать ширину и высоту, как блочные элементы (block).
  Вокруг элемента есть пробелы, как в тексте.
  Поддерживают свойства вертикального и горизонтального выравнивания.

.........................................................................

Веса (специфичность) селекторов в CSS определяют приоритет применения стилей к элементам.

Правила расчета веса:

Теги и псевдо-элементы (например, p) - вес 1
Классы, псевдо-классы и атрибуты (например, .class) - вес 10
Идентификаторы (например, #id) - вес 100
Инлайн-стили (style="") - вес 1000
Вес селектора равен сумме весов составляющих его частей:

div - вес 1
.class - вес 10
section p - вес 2 (1 + 1)
#id .class - вес 110
Правило с бОльшим весом имеет более высокий приоритет.

Если веса равны, то приоритет имеет правило, расположенное ниже в коде.
*/
